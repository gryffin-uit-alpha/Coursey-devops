name: Backend CI/CD

on:
  push:
    branches: ["main"]
    paths:
      - "back-end/**"
      - "helm-charts/**"
      - ".github/workflows/backend.yml"
  workflow_dispatch:
    inputs:
      force_rebuild_all:
        description: "Force rebuild all services (ignore path filtering)"
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  security-events: write

# Configure these as GitHub Repository Variables (Settings > Secrets and variables > Variables)
env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
  ECR_REPO_PREFIX: ${{ vars.ECR_REPO_PREFIX || 'coursey' }}

jobs:
  # ============================================================
  # STEP 1: Detect which services have changed
  # ============================================================
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      php: ${{ steps.filter.outputs.php }}
      python: ${{ steps.filter.outputs.python }}
      nginx: ${{ steps.filter.outputs.nginx }}
      mysql: ${{ steps.filter.outputs.mysql }}
      shared: ${{ steps.filter.outputs.shared }}
      any_service: ${{ steps.check.outputs.any_service }}
      services_to_build: ${{ steps.matrix.outputs.services }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for git diff

      # Use dorny/paths-filter for reliable change detection
      - name: Detect Changed Paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            php:
              - 'back-end/php/**'
              - 'back-end/app/**'
            python:
              - 'back-end/python/**'
            nginx:
              - 'back-end/nginx/**'
              - 'back-end/app/public/**'
            mysql:
              - 'back-end/mysql/**'
            shared:
              - 'back-end/.env*'
              - 'back-end/docker-compose.yml'
              - '.github/workflows/backend.yml'

      # Check if any service needs building
      - name: Check for Any Changes
        id: check
        run: |
          if [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.shared }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.php }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.python }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.nginx }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.mysql }}" == "true" ]]; then
            echo "any_service=true" >> $GITHUB_OUTPUT
          else
            echo "any_service=false" >> $GITHUB_OUTPUT
          fi

      # Build dynamic matrix of services to build
      - name: Build Service Matrix
        id: matrix
        run: |
          FORCE="${{ github.event.inputs.force_rebuild_all }}"
          SHARED="${{ steps.filter.outputs.shared }}"

          services=()

          # If force rebuild or shared files changed, build all
          if [[ "$FORCE" == "true" ]] || [[ "$SHARED" == "true" ]]; then
            services=('{"name":"php","dockerfile":"back-end/php/Dockerfile"}' 
                      '{"name":"python","dockerfile":"back-end/python/Dockerfile"}'
                      '{"name":"nginx","dockerfile":"back-end/nginx/Dockerfile"}'
                      '{"name":"mysql","dockerfile":"back-end/mysql/Dockerfile"}')
          else
            # Only add changed services
            [[ "${{ steps.filter.outputs.php }}" == "true" ]] && \
              services+=('{"name":"php","dockerfile":"back-end/php/Dockerfile"}')
            [[ "${{ steps.filter.outputs.python }}" == "true" ]] && \
              services+=('{"name":"python","dockerfile":"back-end/python/Dockerfile"}')
            [[ "${{ steps.filter.outputs.nginx }}" == "true" ]] && \
              services+=('{"name":"nginx","dockerfile":"back-end/nginx/Dockerfile"}')
            [[ "${{ steps.filter.outputs.mysql }}" == "true" ]] && \
              services+=('{"name":"mysql","dockerfile":"back-end/mysql/Dockerfile"}')
          fi

          # Convert to JSON array
          if [ ${#services[@]} -eq 0 ]; then
            echo "services=[]" >> $GITHUB_OUTPUT
          else
            json_array=$(printf '%s\n' "${services[@]}" | jq -s -c '.')
            echo "services=$json_array" >> $GITHUB_OUTPUT
          fi

          echo "Services to build: ${services[*]}"

  # ============================================================
  # STEP 2: SonarQube Scan (runs on any backend change)
  # ============================================================
  sonar-scan:
    name: SonarQube Backend Scan
    needs: detect-changes
    if: needs.detect-changes.outputs.any_service == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure SonarQube Properties
        run: |
          sed -i "s/YOUR_SONAR_ORG/${{ vars.SONAR_ORG }}/g" sonar-backend.properties
          echo "Updated sonar-backend.properties with org: ${{ vars.SONAR_ORG }}"

      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@master
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_BACKEND }}
        with:
          projectBaseDir: .
          args: >
            -Dproject.settings=sonar-backend.properties

  # ============================================================
  # STEP 3: Build & Push ONLY Changed Services
  # ============================================================
  build-push:
    needs: [detect-changes, sonar-scan]
    if: needs.detect-changes.outputs.services_to_build != '[]'
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.define_tag.outputs.tag }}
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services_to_build) }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Define Image Tag (Short SHA)
        id: define_tag
        run: echo "tag=$(echo $GITHUB_SHA | cut -c 1-7)" >> $GITHUB_OUTPUT

      - name: Build ${{ matrix.service.name }} Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPO: ${{ env.ECR_REPO_PREFIX }}/${{ matrix.service.name }}
          IMAGE_TAG: ${{ steps.define_tag.outputs.tag }}
          DOCKERFILE_PATH: ${{ matrix.service.dockerfile }}
        run: |
          echo "ðŸ”¨ Building ${{ matrix.service.name }} (changed files detected)"
          docker build -t $ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPO:latest -f $DOCKERFILE_PATH ./back-end

      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO_PREFIX }}/${{ matrix.service.name }}:${{ steps.define_tag.outputs.tag }}
          format: "sarif"
          output: "trivy-results-${{ matrix.service.name }}.sarif"
          severity: "CRITICAL,HIGH,MEDIUM"
          exit-code: "0"

      - name: Upload Trivy Scan Results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results-${{ matrix.service.name }}.sarif"
          category: trivy-${{ matrix.service.name }}

      - name: Push ${{ matrix.service.name }} to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPO: ${{ env.ECR_REPO_PREFIX }}/${{ matrix.service.name }}
          IMAGE_TAG: ${{ steps.define_tag.outputs.tag }}
        run: |
          echo "ðŸš€ Pushing ${{ matrix.service.name }} to ECR"
          docker push $ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPO:latest

  # ============================================================
  # STEP 4: Deploy to EKS (only if something was built)
  # ============================================================
  deploy-eks:
    needs: [detect-changes, build-push]
    if: always() && needs.detect-changes.outputs.any_service == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0

      - name: Update Kubeconfig
        run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Deploy with Helm
        env:
          TAG: ${{ needs.build-push.outputs.image_tag || github.sha }}
          PHP_CHANGED: ${{ needs.detect-changes.outputs.php }}
          PYTHON_CHANGED: ${{ needs.detect-changes.outputs.python }}
          NGINX_CHANGED: ${{ needs.detect-changes.outputs.nginx }}
          MYSQL_CHANGED: ${{ needs.detect-changes.outputs.mysql }}
          ACM_CERT_ARN: ${{ secrets.ACM_CERTIFICATE_ARN }}
          DOMAIN: ${{ vars.DOMAIN_NAME }}
        run: |
          echo "Deploying version: $TAG"
          echo "Changed services: PHP=$PHP_CHANGED, Python=$PYTHON_CHANGED, Nginx=$NGINX_CHANGED, MySQL=$MYSQL_CHANGED"

          # Build Helm set arguments dynamically for changed services
          HELM_ARGS=""

          # Always set tags for changed services, use 'latest' for unchanged
          if [[ "$PHP_CHANGED" == "true" ]] || [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]]; then
            HELM_ARGS="$HELM_ARGS --set php.image.tag=$TAG"
          fi
          if [[ "$PYTHON_CHANGED" == "true" ]] || [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]]; then
            HELM_ARGS="$HELM_ARGS --set python.image.tag=$TAG"
          fi
          if [[ "$NGINX_CHANGED" == "true" ]] || [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]]; then
            HELM_ARGS="$HELM_ARGS --set nginx.image.tag=$TAG"
          fi
          if [[ "$MYSQL_CHANGED" == "true" ]] || [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]]; then
            HELM_ARGS="$HELM_ARGS --set mysql.image.tag=$TAG"
          fi

          # Inject domain and certificate from secrets/variables
          HELM_ARGS="$HELM_ARGS --set ingress.alb.certificateArn=$ACM_CERT_ARN"
          HELM_ARGS="$HELM_ARGS --set secrets.hostName=$DOMAIN"
          HELM_ARGS="$HELM_ARGS --set appConfig.apiBaseUrl=https://api.$DOMAIN"
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[0].host=api.$DOMAIN"
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[1].host=admin.$DOMAIN"

          helm upgrade --install coursey ./helm-charts/coursey-backend/ \
            --namespace default \
            $HELM_ARGS \
            --timeout 5m \
            --wait
