name: Backend CI/CD

on:
  push:
    branches: ["main"]
    paths:
      - "back-end/**"
      - "helm-charts/**"
      - ".github/workflows/backend.yml"
  workflow_dispatch:
    inputs:
      force_rebuild_all:
        description: "Force rebuild all services (ignore path filtering)"
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  security-events: write

# Configure these as GitHub Repository Variables (Settings > Secrets and variables > Variables)
env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
  ECR_REPO_PREFIX: ${{ vars.ECR_REPO_PREFIX || 'coursey' }}

jobs:
  # ============================================================
  # STEP 1: Detect which services have changed
  # ============================================================
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      php: ${{ steps.filter.outputs.php }}
      python: ${{ steps.filter.outputs.python }}
      nginx: ${{ steps.filter.outputs.nginx }}
      mysql: ${{ steps.filter.outputs.mysql }}
      shared: ${{ steps.filter.outputs.shared }}
      any_service: ${{ steps.check.outputs.any_service }}
      services_to_build: ${{ steps.matrix.outputs.services }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for git diff

      # Use dorny/paths-filter for reliable change detection
      - name: Detect Changed Paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            php:
              - 'back-end/php/**'
              - 'back-end/app/**'
            python:
              - 'back-end/python/**'
            nginx:
              - 'back-end/nginx/**'
              - 'back-end/app/public/**'
            mysql:
              - 'back-end/mysql/**'
            shared:
              - 'back-end/.env*'
              - 'back-end/docker-compose.yml'
              - '.github/workflows/backend.yml'

      # Check if any service needs building
      - name: Check for Any Changes
        id: check
        run: |
          if [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.shared }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.php }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.python }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.nginx }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.mysql }}" == "true" ]]; then
            echo "any_service=true" >> $GITHUB_OUTPUT
          else
            echo "any_service=false" >> $GITHUB_OUTPUT
          fi

      # Build dynamic matrix of services to build
      - name: Build Service Matrix
        id: matrix
        run: |
          FORCE="${{ github.event.inputs.force_rebuild_all }}"
          SHARED="${{ steps.filter.outputs.shared }}"

          services=()

          # If force rebuild or shared files changed, build all
          if [[ "$FORCE" == "true" ]] || [[ "$SHARED" == "true" ]]; then
            services=('{"name":"php","dockerfile":"back-end/php/Dockerfile"}' 
                      '{"name":"python","dockerfile":"back-end/python/Dockerfile"}'
                      '{"name":"nginx","dockerfile":"back-end/nginx/Dockerfile"}'
                      '{"name":"mysql","dockerfile":"back-end/mysql/Dockerfile"}')
          else
            # Only add changed services
            [[ "${{ steps.filter.outputs.php }}" == "true" ]] && \
              services+=('{"name":"php","dockerfile":"back-end/php/Dockerfile"}')
            [[ "${{ steps.filter.outputs.python }}" == "true" ]] && \
              services+=('{"name":"python","dockerfile":"back-end/python/Dockerfile"}')
            [[ "${{ steps.filter.outputs.nginx }}" == "true" ]] && \
              services+=('{"name":"nginx","dockerfile":"back-end/nginx/Dockerfile"}')
            [[ "${{ steps.filter.outputs.mysql }}" == "true" ]] && \
              services+=('{"name":"mysql","dockerfile":"back-end/mysql/Dockerfile"}')
          fi

          # Convert to JSON array
          if [ ${#services[@]} -eq 0 ]; then
            echo "services=[]" >> $GITHUB_OUTPUT
          else
            json_array=$(printf '%s\n' "${services[@]}" | jq -s -c '.')
            echo "services=$json_array" >> $GITHUB_OUTPUT
          fi

          echo "Services to build: ${services[*]}"

  # ============================================================
  # STEP 2: SonarQube Scan (runs on any backend change)
  # ============================================================
  sonar-scan:
    name: SonarQube Backend Scan
    needs: detect-changes
    if: needs.detect-changes.outputs.any_service == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure SonarQube Properties
        run: |
          sed -i "s/YOUR_SONAR_ORG/${{ vars.SONAR_ORG }}/g" sonar-backend.properties
          echo "Updated sonar-backend.properties with org: ${{ vars.SONAR_ORG }}"

      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@master
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_BACKEND }}
        with:
          projectBaseDir: .
          args: >
            -Dproject.settings=sonar-backend.properties

  # ============================================================
  # STEP 3: Build & Push ONLY Changed Services
  # ============================================================
  build-push:
    needs: [detect-changes, sonar-scan]
    if: needs.detect-changes.outputs.services_to_build != '[]'
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.define_tag.outputs.tag }}
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services_to_build) }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Define Image Tag (Short SHA)
        id: define_tag
        run: echo "tag=$(echo $GITHUB_SHA | cut -c 1-7)" >> $GITHUB_OUTPUT

      - name: Build ${{ matrix.service.name }} Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPO: ${{ env.ECR_REPO_PREFIX }}/${{ matrix.service.name }}
          IMAGE_TAG: ${{ steps.define_tag.outputs.tag }}
          DOCKERFILE_PATH: ${{ matrix.service.dockerfile }}
        run: |
          # Create .env file if missing (required for Docker build context)
          if [ ! -f ./back-end/.env ]; then
            if [ -f ./back-end/.env.example ]; then
              cp ./back-end/.env.example ./back-end/.env
              echo "‚úÖ Created .env from .env.example"
            else
              touch ./back-end/.env
              echo "‚ö†Ô∏è Created empty .env"
            fi
          fi

          echo "üî® Building ${{ matrix.service.name }} (changed files detected)"
          docker build -t $ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPO:latest -f $DOCKERFILE_PATH ./back-end

      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO_PREFIX }}/${{ matrix.service.name }}:${{ steps.define_tag.outputs.tag }}
          format: "sarif"
          output: "trivy-results-${{ matrix.service.name }}.sarif"
          severity: "CRITICAL,HIGH,MEDIUM"
          exit-code: "0"

      - name: Upload Trivy Scan Results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results-${{ matrix.service.name }}.sarif"
          category: trivy-${{ matrix.service.name }}

      - name: Push ${{ matrix.service.name }} to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPO: ${{ env.ECR_REPO_PREFIX }}/${{ matrix.service.name }}
          IMAGE_TAG: ${{ steps.define_tag.outputs.tag }}
        run: |
          echo "üöÄ Pushing ${{ matrix.service.name }} to ECR"
          docker push $ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPO:latest

  # ============================================================
  # STEP 4: Deploy to EKS (only if something was built)
  # ============================================================
  deploy-eks:
    needs: [detect-changes, build-push]
    if: always() && needs.detect-changes.outputs.any_service == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Update Kubeconfig
        run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Deploy with Helm
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          TAG: ${{ needs.build-push.outputs.image_tag || github.sha }}
          PHP_CHANGED: ${{ needs.detect-changes.outputs.php }}
          PYTHON_CHANGED: ${{ needs.detect-changes.outputs.python }}
          NGINX_CHANGED: ${{ needs.detect-changes.outputs.nginx }}
          MYSQL_CHANGED: ${{ needs.detect-changes.outputs.mysql }}
          ACM_CERT_ARN: ${{ secrets.ACM_CERTIFICATE_ARN }}
          DOMAIN: ${{ vars.DOMAIN_NAME }}
        run: |
          echo "Deploying version: $TAG"
          echo "ECR Registry: $ECR_REGISTRY"
          echo "Changed services: PHP=$PHP_CHANGED, Python=$PYTHON_CHANGED, Nginx=$NGINX_CHANGED, MySQL=$MYSQL_CHANGED"

          # Build Helm set arguments dynamically for changed services
          HELM_ARGS=""

          # Set ECR registry for all services (replace placeholder in values.yaml)
          HELM_ARGS="$HELM_ARGS --set php.image.repository=$ECR_REGISTRY/${{ env.ECR_REPO_PREFIX }}/php"
          HELM_ARGS="$HELM_ARGS --set python.image.repository=$ECR_REGISTRY/${{ env.ECR_REPO_PREFIX }}/python"
          HELM_ARGS="$HELM_ARGS --set nginx.image.repository=$ECR_REGISTRY/${{ env.ECR_REPO_PREFIX }}/nginx"
          HELM_ARGS="$HELM_ARGS --set mysql.image.repository=$ECR_REGISTRY/${{ env.ECR_REPO_PREFIX }}/mysql"

          # Always set tags for changed services, use 'latest' for unchanged
          if [[ "$PHP_CHANGED" == "true" ]] || [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]]; then
            HELM_ARGS="$HELM_ARGS --set php.image.tag=$TAG"
          fi
          if [[ "$PYTHON_CHANGED" == "true" ]] || [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]]; then
            HELM_ARGS="$HELM_ARGS --set python.image.tag=$TAG"
          fi
          if [[ "$NGINX_CHANGED" == "true" ]] || [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]]; then
            HELM_ARGS="$HELM_ARGS --set nginx.image.tag=$TAG"
          fi
          if [[ "$MYSQL_CHANGED" == "true" ]] || [[ "${{ github.event.inputs.force_rebuild_all }}" == "true" ]]; then
            HELM_ARGS="$HELM_ARGS --set mysql.image.tag=$TAG"
          fi

          # Inject domain and certificate from secrets/variables
          HELM_ARGS="$HELM_ARGS --set ingress.alb.certificateArn=$ACM_CERT_ARN"
          HELM_ARGS="$HELM_ARGS --set secrets.hostName=$DOMAIN"
          HELM_ARGS="$HELM_ARGS --set appConfig.apiBaseUrl=https://api.$DOMAIN"

          # Set complete ingress host configurations (all fields required to avoid losing serviceName/port)
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[0].name=api"
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[0].host=api.$DOMAIN"
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[0].serviceName=nginx-service"
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[0].port=80"
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[1].name=admin"
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[1].host=admin.$DOMAIN"
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[1].serviceName=nginx-service"
          HELM_ARGS="$HELM_ARGS --set ingress.hosts[1].port=8082"

          helm upgrade --install coursey ./helm-charts/coursey-backend/ \
            --namespace default \
            $HELM_ARGS \
            --timeout 5m \
            --wait

      - name: Debug - Check Deployment Status
        if: failure()
        run: |
          echo "=== Helm Release Status ==="
          helm status coursey --namespace default || true

          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -n default -o wide || true

          echo ""
          echo "=== Ingress Status ==="
          kubectl get ingress -n default -o yaml || true

          echo ""
          echo "=== Recent Events ==="
          kubectl get events -n default --sort-by='.lastTimestamp' | tail -50 || true

          echo ""
          echo "=== Describe Failing Pods ==="
          for pod in $(kubectl get pods -n default --field-selector=status.phase!=Running -o name); do
            echo "--- Describing $pod ---"
            kubectl describe -n default $pod || true
            echo "--- Logs for $pod ---"
            kubectl logs -n default $pod --all-containers --tail=100 || true
          done

      - name: Get Ingress URL
        if: success()
        run: |
          echo "=== Deployment Successful ==="
          INGRESS_HOST=$(kubectl get ingress coursey-alb-ingress -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "üöÄ Application deployed successfully!"
          echo "üìç Ingress URL: https://$INGRESS_HOST"
          echo "üìç API URL: https://api.${{ vars.DOMAIN_NAME }}"
          echo "üìç Admin URL: https://admin.${{ vars.DOMAIN_NAME }}"
